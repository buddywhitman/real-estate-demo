import { GoogleGenAI, Type } from "@google/genai";
import { Property, Lead, LeadStatus } from '../types';

const apiKey = process.env.API_KEY || 'dummy_key';
const ai = new GoogleGenAI({ apiKey });

export const generatePropertyDescription = async (
  title: string,
  location: string,
  features: string[],
  type: string,
  price: string
): Promise<string> => {
  try {
    if (apiKey === 'dummy_key') {
      return "Simulation: API Key missing. This would be a luxurious description generated by Gemini Flash.";
    }

    const prompt = `
      Write a compelling, luxury real estate description for a property with the following details:
      Title: ${title}
      Location: ${location}
      Type: ${type}
      Price: ${price}
      Key Features: ${features.join(', ')}

      The tone should be sophisticated, exclusive, and persuasive. Keep it under 150 words.
    `;

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: prompt,
    });

    return response.text || "Description generation failed.";
  } catch (error) {
    console.error("Gemini API Error:", error);
    return "Could not generate description at this time.";
  }
};

export interface GatekeeperResponse {
  botReply: string;
  suggestedProperties?: Property[];
  action?: 'CREATE_LEAD' | 'UPDATE_LEAD' | 'NONE' | 'STOP_AI';
  extractedData?: Partial<Lead>;
}

export const gatekeeperChat = async (
  userMessage: string,
  chatHistory: { sender: 'user' | 'bot', text: string }[],
  inventory: Property[]
): Promise<GatekeeperResponse> => {
  if (apiKey === 'dummy_key') {
    return {
       botReply: "I am a simulation. Please configure a valid API key to chat with the real AI.",
       action: 'NONE'
    };
  }

  // 1. Context Detection: Which property is the user talking about?
  let relevantProperty: Property | undefined;
  const recentContext = (userMessage + " " + (chatHistory[chatHistory.length-1]?.text || "")).toLowerCase();
  
  relevantProperty = inventory.find(p => recentContext.includes(p.title.toLowerCase()));

  // 2. Build Base Prompt
  const inventorySummary = inventory.map(p => 
    `ID: ${p.id} | Name: ${p.title} | Loc: ${p.location} | Price: ${p.price} | Type: ${p.bhk} BHK`
  ).join('\n');

  const historyText = chatHistory.slice(-6).map(m => `${m.sender.toUpperCase()}: ${m.text}`).join('\n');

  const systemInstruction = `
    You are an intelligent Real Estate Gatekeeper Bot for "Nexus Estate".
    
    INVENTORY SUMMARY:
    ${inventorySummary}

    RULES:
    1. FILTERING: If new user, ask Budget, Location, Config (BHK).
    2. MATCHING: Search inventory. If matches found, suggest top 2.
    3. DOCUMENT LOOKUP: If the user asks specific questions (maintenance, pets, gym rules) about a specific property, refer to the provided PDF documents.
    4. CLOSING: If user likes a property, push for Site Visit -> Set Action UPDATE_LEAD.
    
    Output JSON format:
    {
      "botReply": "string",
      "action": "CREATE_LEAD" | "UPDATE_LEAD" | "NONE" | "STOP_AI",
      "extractedData": {
        "budget": "string",
        "interestedIn": ["string property titles"],
        "confidenceScore": number (0-100),
        "status": "LeadStatus"
      }
    }
  `;

  // 3. Construct Payload
  // If we found a relevant property with PDF documents, attach them as inlineData
  const contentParts: any[] = [];

  if (relevantProperty && relevantProperty.documents.length > 0) {
     relevantProperty.documents.forEach(doc => {
        if (doc.base64 && doc.mimeType === 'application/pdf') {
           // Attach PDF for "Real Parsing"
           contentParts.push({
             inlineData: {
               data: doc.base64,
               mimeType: 'application/pdf'
             }
           });
           contentParts.push({ text: `[System: The above attachment is the official document for ${relevantProperty!.title}. Use it to answer the user's question.]` });
        } else {
           // Fallback for text documents
           contentParts.push({ text: `[Document Content for ${relevantProperty!.title}]: ${doc.content}` });
        }
     });
  }

  // Add History and User Message
  contentParts.push({ text: `
    CONVERSATION HISTORY:
    ${historyText}
    
    USER QUERY: ${userMessage}
  `});

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: contentParts,
      config: {
        systemInstruction: systemInstruction,
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            botReply: { type: Type.STRING },
            action: { type: Type.STRING },
            extractedData: {
              type: Type.OBJECT,
              properties: {
                budget: { type: Type.STRING },
                interestedIn: { type: Type.ARRAY, items: { type: Type.STRING } },
                confidenceScore: { type: Type.NUMBER },
                status: { type: Type.STRING }
              }
            }
          }
        }
      }
    });

    const text = response.text;
    if (!text) throw new Error("No response");
    
    const parsed = JSON.parse(text);
    
    const suggestions: Property[] = [];
    if (parsed.extractedData?.interestedIn) {
        parsed.extractedData.interestedIn.forEach((title: string) => {
            const match = inventory.find(p => p.title.toLowerCase().includes(title.toLowerCase()));
            if(match) suggestions.push(match);
        });
    }

    return {
      botReply: parsed.botReply,
      action: parsed.action,
      extractedData: parsed.extractedData,
      suggestedProperties: suggestions
    };

  } catch (error) {
    console.error("Gatekeeper Error:", error);
    return {
      botReply: "I'm having trouble processing that right now. Let me connect you with a human agent.",
      action: 'STOP_AI'
    };
  }
};